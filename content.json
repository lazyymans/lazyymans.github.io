[{"title":"Spring Cloud微服务架构（二）服务消费者","date":"2018-05-07T11:36:11.000Z","path":"2018/05/07/Spring-Cloud微服务架构（二）服务消费者/","text":"在上一篇中《Spring Cloud微服务架构（一）高可用服务注册与发现》中，我们已经创建了服务注册中心，并且注册了一个服务提供者 pay-server，那么接下来我们要怎么去消费提供者提供的接口呢？ 首先创建 Provider Server 服务提供方创建一个基本的Provider Server 项目，在pom.xml 引入以下依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.blog&lt;/groupId&gt; &lt;artifactId&gt;provider-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;provider-server&lt;/name&gt; &lt;description&gt;provider-server&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 服务发现 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 断路器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 创建好Provider Server 项目后，主应用类将@SpringBootApplication修改为SpringCloudApplication注解，将此服务注册到Eureka Server中，代码如下： 12345678@EnableEurekaClient@SpringCloudApplicationpublic class ProviderServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProviderServerApplication.class, args); &#125;&#125; 配置application.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344---server: port: 9300eureka: client: service-url: defaultZone: http://peer1:9100/eureka/ instance: instanceId: $&#123;spring.application.name&#125;:$&#123;server.port&#125; prefer-ip-address: falsespring: application: name: provider-server profiles: peer1---server: port: 9301eureka: client: service-url: defaultZone: http://peer1:9100/eureka/ instance: instanceId: $&#123;spring.application.name&#125;:$&#123;server.port&#125; prefer-ip-address: falsespring: application: name: provider-server profiles: peer2---server: port: 9302eureka: client: service-url: defaultZone: http://peer1:9100/eureka/ instance: instanceId: $&#123;spring.application.name&#125;:$&#123;server.port&#125; prefer-ip-address: falsespring: application: name: provider-server profiles: peer3 这里有三个配置，用来测试我们的负载均衡，服务调用方具体是访问的是那个端口下的服务。 接下来编写一个提供其他服务调用的接口，这里也就是我们的Pay Server来调用，代码如下： 1234567891011121314151617@RestController@RequestMapping(\"/api/provider\")public class TestProviderController &#123; private final static Logger log = LoggerFactory.getLogger(TestProviderController.class); @Autowired private LoadBalancerClient loadBalancerClient; @RequestMapping(\"testProvider\") public String testProvider()&#123; ServiceInstance instance = this.loadBalancerClient.choose(\"provider-server\"); log.info(\"&gt;&gt;&gt;&gt;&gt;\" + \" \" + instance.getServiceId() + \":\" + instance.getHost() + \":\" + instance.getPort()); return \"testProvider success\"; &#125;&#125; 到此，服务提供方就已经做好了。 RibbonRibbon 是一个客户端负载均衡器，可以让您对HTTP和TCP客户端的行为有很多控制权。Feign已经使用Ribbon，因此，如果您使用@FeignClient，此部分也适用。原理我们这里就不做过多说明，直接进入实战演练。 下面我们通过实例看看如何使用Ribbon来调用服务，并实现客户端的均衡负载。 上面，我们已经创建好了Provider Server服务提供方，在Pay Server中使用Ribbon来进行消费。 1、在pom.xml 中引入新的依赖12345678910&lt;!-- 服务消费者 ribbon openfeign 这里直接把两个依赖都加上 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 2、修改Pay Server主应用类：1234567891011121314@EnableEurekaClient@SpringCloudApplicationpublic class PayServerApplication &#123; @Bean @LoadBalanced //开启负载均衡 RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(PayServerApplication.class, args); &#125;&#125; 3、创建TestPayController.java 来消费Provider Server的 testProvider 服务，通过直接RestTemplate来调用服务。1234567891011121314151617181920212223@RestController@RequestMapping(\"/api/pay\")public class TestPayController &#123; private final static Logger log = LoggerFactory.getLogger(TestPayController.class); @Autowired private RestTemplate restTemplate; @Autowired private LoadBalancerClient loadBalancerClient; /** * Ribbon方式访问 */ @RequestMapping(\"/testProviderRibbon\") public String testProviderRibbon()&#123; ServiceInstance instance = this.loadBalancerClient.choose(\"provider-server\"); log.info(\"&gt;&gt;&gt;&gt;&gt;\" + \" \" + instance.getServiceId() + \":\" + instance.getHost() + \":\" + instance.getPort()); return restTemplate.postForObject(\"http://provider-server/api/provider/testProvider\", null, String.class); &#125;&#125; 4、修改application.yml123456789101112131415161718192021222324252627282930---server: port: 9200eureka: client: service-url: defaultZone: http://peer1:9100/eureka/ instance: instanceId: $&#123;spring.application.name&#125;:$&#123;server.port&#125; prefer-ip-address: falsespring: application: name: pay-server profiles: peer1provider-server: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #轮询# NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #随机分配# NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule #加权响应时间# 断路器 将 hystrix 的超时时间设置成 60000 毫秒（60秒）# 解决第一次请求报超时异常的方案，因为 hystrix 的默认超时时间是 1 秒，因此请求超过该时间后，就会出现页面超时显示 ：hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 60000 以上工作做完之后，我们就可以启动Pay Server和Provider Server了。将Provider Server分别根据配置启动三次（Spring Cloud微服务架构（一）高可用服务注册与发现 有说明如何根据不同配置启动）。启动后如下图接下来我们访问http://localhost:9200/api/pay/testProviderRibbon（也就是我们Pay Server的接口），查看日志和访问结果。调用日志：访问结果：我们可以看到，按顺序访问的端口服务器，这是因为我们在配置负载均衡的时候使用的是轮询模式。修改负载均衡模式（这次我们使用随机分配模式），我们在次调用。调用日志： 可以发现，现在调用的端口服务器是随机的。这里，通过Ribbon的方式来消费服务的方式就已经做好了。 Feign之前我们做Ribbon的时候，已经做了很多的准备工作，并且已经在pom.xml 文件中新添加了Feign 的依赖，所以这里我们直接开始。 1、添加访问远端服务 Feign 客户端ProviderFeginCustomClient.java，代码如下：123456789@FeignClient(name = \"provider-server\")public interface ProviderFeginCustomClient &#123; //两种访问方式都可以 @RequestLine(\"GET /api/provider/testProvider\") //@RequestMapping(value = \"/api/provider/testProvider\", method = RequestMethod.GET) public String testProvider();&#125; 2、在TestProviderController.java中添加 Feign 方式访问的接口，代码如下：123456789101112131415161718192021222324252627282930313233343536@RestController@RequestMapping(\"/api/pay\")public class TestPayController &#123; private final static Logger log = LoggerFactory.getLogger(TestPayController.class); @Autowired private ProviderFeginCustomClient feignClient; @Autowired private RestTemplate restTemplate; @Autowired private LoadBalancerClient loadBalancerClient; /** * Feign方式访问 */ @RequestMapping(\"/testProviderFeign\") public String testProviderFeign()&#123; ServiceInstance instance = this.loadBalancerClient.choose(\"provider-server\"); log.info(\"testProviderFeign &gt;&gt;&gt;&gt;&gt;\" + \" \" + instance.getServiceId() + \":\" + instance.getHost() + \":\" + instance.getPort()); return feignClient.testProvider(); &#125; /** * Ribbon方式访问 */ @RequestMapping(\"/testProviderRibbon\") public String testProviderRibbon()&#123; ServiceInstance instance = this.loadBalancerClient.choose(\"provider-server\"); log.info(\"&gt;&gt;&gt;&gt;&gt;\" + \" \" + instance.getServiceId() + \":\" + instance.getHost() + \":\" + instance.getPort()); return restTemplate.postForObject(\"http://provider-server/api/provider/testProvider\", null, String.class); &#125;&#125; 重新启动Pay Server服务，访问http://localhost:9200/api/pay/testProviderFeign。调用日志：访问结果：根据日志和访问结果，我们的Feign 是配置成功了。这里的端口很明显是随机的，应为我们在做Ribbon的时候将它设置成了随机的负载均衡调度。到此Ribbon和Feign的服务消费就结束了。 那么，我们在开发的时候会想，到底使用Ribbon呢，还是Feign呢？ 现在我们就来分析一波，从代码上来看，我们使用Ribbon很方便快捷，只要在服务主应用类上加入下面一段代码。12345@Bean@LoadBalanced //开启负载均衡RestTemplate restTemplate()&#123; return new RestTemplate();&#125; 然后使用的时候，只要在其中注入 RestTemplate即可使用，通过调用RestTemplate的接口即可，例如下面的代码片 1return restTemplate.postForObject(\"http://provider-server/api/provider/testProvider\", null, String.class); 反观Feign，需要创建一个 Feign 客户端甚至是Feign 的配置（此案例中还未涉及Feign 的配置），显得旧没有那么方便快捷了。我们可以看到上面的 Feign 客户端ProviderFeginCustomClient.java，在调用的时候，注入Feign 客户端，直接调用接口即可，如下面的代码片段。 1return feignClient.testProvider(); 我们发现 Feign的调用方式就很像调用本地的方法，甚至感觉不到我们是在跨服务调用。 这里笔者的想法是这样的，在我们实际的项目中，如果我在消费者服务（这里也就是Pay Server）在不用过多的去调用提供方（这里也就是Provider Server）的接口时，我们倾向于使用Ribbon，因为它够方便，够简单。反之，我们倾向于使用Feign来做服务消费。我们可以看到Feign更具有封装性，将我们所有的服务调用，全部可以封装在 FeignClient 中，维护起来也方便。 我们可以一开始的时候使用Ribbon来做服务间的调用，之后变多的情况下，考虑代码重构。","tags":[{"name":"Ribbon","slug":"Ribbon","permalink":"http://blog.pcluo.com/tags/Ribbon/"},{"name":"Feign","slug":"Feign","permalink":"http://blog.pcluo.com/tags/Feign/"}]},{"title":"Spring Cloud微服务架构（一）高可用服务注册与发现","date":"2018-05-07T09:02:25.000Z","path":"2018/05/07/Spring-Cloud微服务架构（一）高可用服务注册与发现/","text":"创建“服务注册中心”创建一个基础的Spring Boot EurekaServer项目，在pom.xml 中引入需要的依赖​ 注意：在创建Spring Boot 项目时，版本的选择。本次系列文章均采用最新版本的2.0.1版本对应关系​ 为什么要在这里说明一下，因为不同的版本，你写的pom依赖可能不同。如下面的 服务注册依赖，​ 在Spring Boot 1.5.x 版本中 spring-cloud-starter-eureka-server 是这个，如何去找准确的依赖，要去​ 看官方文档，去里面找。如Spring Boot 2.0.1 Eureka Server 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.geeur.demo.cloud&lt;/groupId&gt; &lt;artifactId&gt;eureka-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eureka-server&lt;/name&gt; &lt;description&gt;eureka-server&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.M9&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 服务注册 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 断路器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 创建好EurekaServer 项目后，通过@EnableEurekaServer注解启动一个服务注册中心提供给其他应用进行对话。这一步只需要在你的Spring Boot 应用中添加这个注解，就可以开启此功能。代码如下： 12345678@EnableEurekaServer@SpringCloudApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 这里使用更改了创建项目时的@SpringBootApplication注解，变为@SpringCloudApplication，其实就是一个注解的整合，这里不做过多说明。 注意：使用@SpringCloudApplication时，需要加入断路器的依赖。使用@SpringBootApplication则可以不加断路器依赖，原因是@SpringCloudApplication注解里面包含@EnableCircuitBreaker这个注解，它需要断路器的自动配置。接下来就是application.yml 的配置(默认创建项目时生成的是application.properties 文件) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108# 测试环境 peer1---# 服务端口server: port: 9100eureka: server: # 正式环境不推荐加入此配置，以下server 配置为 Eureka Server的自我保护机制，在我们测试时候加入，是为了看效果 eviction-interval-timer-in-ms: 5000 enable-self-preservation: false client: # 是否向服务注册中心注册自己 register-with-eureka: true # 是否检索服务 fetch-registry: true serviceUrl: defaultZone: http://peer1:9100/eureka/,http://peer2:9101/eureka/,http://peer3:9102/eureka/ instance: instanceId: $&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125; prefer-ip-address: false hostname: peer1 appname: $&#123;spring.application.name&#125; # 以下两个配置正式环境推荐使用默认值，不建议修改 # 表示eureka client间隔多久去拉取服务注册信息，默认为30秒，对于api-gateway，如果要迅速获取服务注册状态，可以缩小该值，比如5秒 lease-renewal-interval-in-seconds: 5 # 表示eureka server至上一次收到client的心跳之后，等待下一次心跳的超时时间，在这个时间内若没收到下一次心跳，则将移除该instance lease-expiration-duration-in-seconds: 10spring: application: # 微服务名称，后续在调用的时候只需要使用该名称就可以进行服务的访问 name: eureka-server profiles: peer1# 测试环境 peer2---server: port: 9101eureka: server: eviction-interval-timer-in-ms: 5000 enable-self-preservation: false client: register-with-eureka: true fetch-registry: true serviceUrl: defaultZone: http://peer1:9100/eureka/,http://peer2:9101/eureka/,http://peer3:9102/eureka/ instance: instanceId: $&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125; prefer-ip-address: false hostname: peer2 appname: $&#123;spring.application.name&#125; lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 10spring: application: name: eureka-server profiles: peer2# 测试环境 peer3---server: port: 9102eureka: server: eviction-interval-timer-in-ms: 5000 enable-self-preservation: false client: register-with-eureka: true fetch-registry: true serviceUrl: defaultZone: http://peer1:9100/eureka/,http://peer2:9101/eureka/,http://peer3:9102/eureka/ instance: instanceId: $&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125; prefer-ip-address: false hostname: peer3 appname: $&#123;spring.application.name&#125; lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 10spring: application: name: eureka-server profiles: peer3#生产环境推荐配置---server: port: 9103eureka: client: serviceUrl: defaultZone: http://peer1:9100/eureka/,http://peer2:9101/eureka/,http://peer3:9102/eureka/,http://prod:9103/eureka/ instance: instanceId: $&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125; prefer-ip-address: false hostname: prod appname: $&#123;spring.application.name&#125;spring: application: name: eureka-server profiles: prod 注意：这里需要在你们的 hosts 文件中加入如下配置 123127.0.0.1 peer1127.0.0.1 peer2127.0.0.1 peer3 因为我们要做Eureka Server 的集群，所以这个在我的application.yml 配置中，分别有三个配置peer1、peer2、peer3。然后我们启动Eureka Server 三次，根据不同的配置，在IDEA 中如何启动这三个配置。 修改Program arguments: –spring.profiles.active=peer1、 –spring.profiles.active=peer2、–spring.profiles.active=peer3，启动三次即可。任意访问其中一个： 可以看到我们的集群已经搭建好了。这里我们为什么要注册自己（register-with-eureka: true和fetch-registry: true这两个配置），我们可以看到下面那个红框中的数据，registered-replicas（注册副本）、unavailable-replicas（不可用副本）、available-replicas（可用副本）。当我们其中某一个Eureka Server 死掉的时候，unavailable-replicas就会有死掉的是哪一个Eureka Server，根据这个，我们就可以快速的重启对应的Eureka Server。 通常情况下是，启动两个注册中心c1和c2，但是在c1注册中心的available-replicas项中没有c2存在，反而是unavailable-replicas中有。 加入的配置为： 12345# 1、默认即可，源码中，这两个配置均为 trueregister-with-eureka: truefetch-registry: true# 2、eureka.client.serviceUrl.defaultZone配置项的地址，不能使用localhost，要使用service-center-1之类的域名，通过host映射到127.0.0.1；这里使用的是peer1、peer2、peer3# 3、spring.application.name或eureka.instance.appname必须一致； 现在我们将peer2 的Eureka Server 死掉，再看情况 我们可以看到 http://peer2:9101/eureka/ 出现在 unavailable-replicas，在我们的注册区EUREKA-SERVER 中也只有两个Eureka Server。 创建“服务提供方”创建提供支付服务的为服务模块，并向服务注册中心注册 创建一个名叫Pay Server 的Spring Boot 服务模块，在pom.xml 引入如下配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.geeur&lt;/groupId&gt; &lt;artifactId&gt;pay-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;pay-server&lt;/name&gt; &lt;description&gt;pay-server&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.M9&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 服务发现 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 断路器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;finalName&gt;weixin-server&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 然后在主应用类上加上@EnableDiscoveryClient注解，该注解能激活Eureka中的DiscoveryClient实现，才能实现Controller中对服务信息的输出。 1234567891011/** * 把 @SpringBootApplication 修改为 @SpringCloudApplication * 此注解中已经包含了 @EnableDiscoveryClient 注解 */@SpringCloudApplicationpublic class PayServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(PayServerApplication.class, args); &#125;&#125; 接下来就是application.yml 的配置(默认创建项目时生成的是application.properties 文件) 1234567891011121314server: port: 9200eureka: client: service-url: # 指定服务注册中心的位置（这里指定集群中的一个就可以） defaultZone: http://peer1:9100/eureka/ instance: instanceId: $&#123;spring.application.name&#125;:$&#123;server.port&#125; prefer-ip-address: falsespring: application: # 微服务名称，后续在调用的时候只需要使用该名称就可以进行服务的访问 name: pay-server 启动Pay Server 项目，访问我们的http://peer1:9100，显示如下图： 我们可以看到我们的服务中心已经注册了Pay Server，现在我们将 peer1的Eureka Server杀掉，为什么杀掉它，因为我们的Pay Server 中，defaultZone是向http://peer1:9100/eureka/注册的。显示如下图： 可以看到，我们的unavailable-replicas 中出现了http://peer1:9100/eureka/，但是我们的注册区任然是存在Pay Server 这个服务的。","tags":[{"name":"Eureka","slug":"Eureka","permalink":"http://blog.pcluo.com/tags/Eureka/"}]},{"title":"HashMap和HashSet实现原理","date":"2018-05-03T08:50:57.000Z","path":"2018/05/03/HashMap和HashSet实现原理/","text":"HashMap分析","tags":[{"name":"HashMap HashSet","slug":"HashMap-HashSet","permalink":"http://blog.pcluo.com/tags/HashMap-HashSet/"}]},{"title":"Servlet 生命周期","date":"2018-05-03T06:00:33.000Z","path":"2018/05/03/Servlet 生命周期/","text":"一个Servlrt 的生命周期可以被定义为从创建到销毁的整个过程。以下是Servlrt 所遵循的路径，我们先看下Servlet 有哪些方法，中点关注那些方法（init()、service()、destroy()） Servlrt 的生命周期分为三个阶段： 1、初始化阶段1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465类加载器加载Servlet --&gt; 容器创建Servlet --&gt; 容器调用Servlet.init()Servlet.init()只会被调用一次，它只在Servlet 创建的时候调用，之后的任何用户请求都不会在被调用。这里在Servlet 创建并初始化的时候，tomcat 会把它放到容器的缓存中来进行管理，在下一次访问的时候看缓存中是否有这个Servlet，如果有则直接拿出来调用。默认情况下Servlet 是什么时候被创建的呢? 我们在web.xml 里面配置我们的Servlet 代码如下 &lt;servlet&gt; &lt;!-- servlet的内部名称，自定义。尽量有意义 --&gt; &lt;servlet-name&gt;defaultServlet&lt;/servlet-name&gt; &lt;!-- servlet的类全名： 包名+简单类名 --&gt; &lt;servlet-class&gt;com.blog.demo.servlet.DefaultServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- servlet的映射配置 --&gt; &lt;servlet-mapping&gt; &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt; &lt;servlet-name&gt;defaultServlet&lt;/servlet-name&gt; &lt;!-- servlet的映射路径（访问servlet的名称） --&gt; &lt;url-pattern&gt;/servlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Servlet public class DefaultServlet extends HttpServlet &#123; public DefaultServlet() &#123; System.out.println(\"DefaultServlet construct\"); &#125; @Override public void init() throws ServletException &#123; System.out.println(\"DefaultServlet init\"); super.init(); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"DefaultServlet doGet\"); super.doGet(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(\"DefaultServlet doPost\"); super.doPost(req, resp); &#125; @Override public void destroy() &#123; System.out.println(\"DefaultServlet destroy\"); super.destroy(); &#125;&#125;此时我们启动我们的容器，这里以tomcat容器为例，启动我们的tomcat 查看启动日志，我们并没有发现控制台有打印 DefaultServlet init，这是我们访问一下我们的Servlet doGet方法我们看打印的日志DefaultServlet constructDefaultServlet initDefaultServlet doGet即Servlet 在我们访问的时候被创建，并且初始化，之后再次调用不再调用Servlet.init()方法。第一次调用Servlet.doGet()的方法时，tomcat 会判断容器中是否有这个Servlet 的实例，如果有则直接调用Servlet.doGet()，如果没有则创建Servlet 并调用 init 方法。之后再次访问就不再调用Servlet.init()日志如下图： 1234567891011121314151617通常我们会在 web.xml Servlet 配置里面加上 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 这样一个配置，这个配置的作用就是告诉web容器(tomcat) 在容器启动时就加载这个Servlet，现在我们把这个配置加上，然后再启动web容器，我们发现tomcat 在启动时就帮我们创建了Servlet 并且初始化 &lt;servlet&gt; &lt;!-- servlet的内部名称，自定义。尽量有意义 --&gt; &lt;servlet-name&gt;defaultServlet&lt;/servlet-name&gt; &lt;!-- servlet的类全名： 包名+简单类名 --&gt; &lt;servlet-class&gt;com.blog.demo.servlet.DefaultServlet&lt;/servlet-class&gt; &lt;!-- 默认容器启动时创建Servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- servlet的映射配置 --&gt; &lt;servlet-mapping&gt; &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt; &lt;servlet-name&gt;defaultServlet&lt;/servlet-name&gt; &lt;!-- servlet的映射路径（访问servlet的名称） --&gt; &lt;url-pattern&gt;/servlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 2、相应客户端请求阶段12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Servlet 在创建好之后，就处于响应就绪状态，只要有请求过来就会执行Servlet.service()。为什么我们在上面直接说请求Servlet.doGet()方法呢？以下是HttpServlet 对service 的处理public abstract class HttpServlet extends GenericServlet implements Serializable &#123; public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; HttpServletRequest request; HttpServletResponse response; try &#123; request = (HttpServletRequest)req; response = (HttpServletResponse)res; &#125; catch (ClassCastException var6) &#123; throw new ServletException(\"non-HTTP request or response\"); &#125; this.service(request, response); &#125; protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getMethod(); long lastModified; if (method.equals(\"GET\")) &#123; lastModified = this.getLastModified(req); if (lastModified == -1L) &#123; this.doGet(req, resp); &#125; else &#123; long ifModifiedSince = req.getDateHeader(\"If-Modified-Since\"); if (ifModifiedSince &lt; lastModified / 1000L * 1000L) &#123; this.maybeSetLastModified(resp, lastModified); this.doGet(req, resp); &#125; else &#123; resp.setStatus(304); &#125; &#125; &#125; else if (method.equals(\"HEAD\")) &#123; lastModified = this.getLastModified(req); this.maybeSetLastModified(resp, lastModified); this.doHead(req, resp); &#125; else if (method.equals(\"POST\")) &#123; this.doPost(req, resp); &#125; else if (method.equals(\"PUT\")) &#123; this.doPut(req, resp); &#125; else if (method.equals(\"DELETE\")) &#123; this.doDelete(req, resp); &#125; else if (method.equals(\"OPTIONS\")) &#123; this.doOptions(req, resp); &#125; else if (method.equals(\"TRACE\")) &#123; this.doTrace(req, resp); &#125; else &#123; String errMsg = lStrings.getString(\"http.method_not_implemented\"); Object[] errArgs = new Object[]&#123;method&#125;; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(501, errMsg); &#125; &#125;&#125;通过HttpServlet 的源码，我们知道在调用service 方法的时候，它会根据请求类型，调用自身的对应的 doGet，doPost，doPut，doDelete ...等方法所以我们在自定义的时候只要Override 这些方法即可。当请求过来的时候，web容器会创建一个新的线程来处理这个请求，web容器来调用对应Servlet.service()，方法Servlet.service()根据请求调用doGet、doPost等方法并完成请求响应，之后线程结束，请求结束。 3、销毁阶段123web容器销毁阶段，会调用应用中所有的Servlet.destroy()。该方法在整个生命周期也是只被调用一次，在Servlet 被销毁的时候，此时我们可以释放掉Servlet 所占用的资源。例如关闭与数据库的连接。下图是容器销毁时调用","tags":[{"name":"源码分析之Servlet","slug":"源码分析之Servlet","permalink":"http://blog.pcluo.com/tags/源码分析之Servlet/"}]},{"title":"博客搭建","date":"2018-03-27T03:15:00.000Z","path":"2018/03/27/博客快速搭建/","text":"快速搭建参看网址搭建 参看网址多机使用 Create a new post and commit1234567cd 你的博客目录$ hexo new \"My New Post\" // /你的博客目录/source/_posts/My New Post.mdgit commit -am 'add My New Post.md and commit'git pushhexo clean // 先进行cleanhexo d -g // 更新到master分支","tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://blog.pcluo.com/tags/博客搭建/"}]}]